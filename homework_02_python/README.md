Pratice Report(9/23/2018)
=========================

林昊晗，2015300010
------------------

1. 数值计算 numpy
-----------------

### EXERCISE 1.1

对于一个存在在数组，如何添加一个用0填充的边界?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
# -*- coding: utf-8 -*-
import numpy as ny
m = int (input("row: "))
n = int (input("collum: "))

a = ny.random.rand(m,n)
print(a, '\n')

b = ny.zeros((m,1))

b_1 = ny.c_[b,a,b]

c = ny.zeros((1,n+2))

trans_a = ny.r_[c,b_1,c]

print(trans_a)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
row: 2
collum: 3
[[0.81703131 0.91656208 0.5760559 ]
 [0.37342728 0.69168514 0.08302869]] 

[[0.         0.         0.         0.         0.        ]
 [0.         0.81703131 0.91656208 0.5760559  0.        ]
 [0.         0.37342728 0.69168514 0.08302869 0.        ]
 [0.         0.         0.         0.         0.        ]]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

思路：  
利用ny.c_[]和ny.r[]分别实现列和行的插入。矩阵的插入还有许多相关函数，如：  
ny.insert(a, 0, values=b,
axis=0),是将b以行为单位插入到a的第0行前（即作为第0行），如axis =
1则是以列为单位插入。  
np.row_stack(tuple)，np.column_stack((a,b.T))与最开始的方法也一样，需注意行向量要转置成为列向量才能以列为单位插入。  
  
函数：  
int(input()):将输入的string转为int  
ny.random.rand(m,n)：产生一个m行n列的在[0,1)区间的随机矩阵  
ny.zeros((m,1))：产生m行1列的全零矩阵，即一列零向量组成的矩阵。注意输入参数是tuple类型。如为list则返回向量。ny.c_[]函数只接受矩阵类型参数。

### EXERCISE 1.2

创建一个 5x5的矩阵，并设置值1,2,3,4落在其对角线下方位置

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
import numpy as np
a = np.random.rand(5,5)
print(a, '\n')

b = a.flatten()
print(b, '\n')

for i in range(4):
    b[5+6*i] = i + 1

b.shape = 5,5
print(b)
#or:
#a.shape = 1,-1
#print(a, '\n')

#for i in range(4):
#    a[0,5+6*i] = i + 1

#a.shape = 5,5
#print(a)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[[0.22471426 0.3113509  0.21325489 0.4714159  0.99871859]
 [0.01225978 0.13453505 0.40100895 0.78429246 0.39771094]
 [0.96894665 0.02221192 0.8852569  0.42981729 0.00680467]
 [0.39537083 0.27650989 0.72338254 0.90514993 0.87379516]
 [0.12199926 0.5947831  0.18908765 0.40976328 0.95274716]] 

[0.22471426 0.3113509  0.21325489 0.4714159  0.99871859 0.01225978
 0.13453505 0.40100895 0.78429246 0.39771094 0.96894665 0.02221192
 0.8852569  0.42981729 0.00680467 0.39537083 0.27650989 0.72338254
 0.90514993 0.87379516 0.12199926 0.5947831  0.18908765 0.40976328
 0.95274716] 

(25,)
[[0.22471426 0.3113509  0.21325489 0.4714159  0.99871859]
 [1.         0.13453505 0.40100895 0.78429246 0.39771094]
 [0.96894665 2.         0.8852569  0.42981729 0.00680467]
 [0.39537083 0.27650989 3.         0.90514993 0.87379516]
 [0.12199926 0.5947831  0.18908765 4.         0.95274716]]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

思路：  
产生5*5随机矩阵，通过a.reshape/a.shape/a.flatten函数修改矩阵为一行向量组成的矩阵（前两者）或一行向量，然后通过for循环将1,2,3,4赋值给向量下标为5,5+6,5+6*2,5+6\*3的元素。本题不能用np.diag(a,-1)赋值的原因是,diag是函数，返回值不能更改。  
  
函数：  
a.shape：不需要输入参数，可以通过赋值改变矩阵结构（类似reshape），-1会自动计算替换为矩阵所有元素数。  
a.flatten()：有输入，省略会启用默认值  


### EXERCISE 1.3

创建一个8x8 的矩阵，并且设置成国际象棋棋盘样式（黑可以用0, 白可以用1）

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
import numpy as ny
a = ny.array([[int(bin(n+m)[-1]) for n in range(8)] for m in range(8)])
print(a)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[[0 1 0 1 0 1 0 1]
 [1 0 1 0 1 0 1 0]
 [0 1 0 1 0 1 0 1]
 [1 0 1 0 1 0 1 0]
 [0 1 0 1 0 1 0 1]
 [1 0 1 0 1 0 1 0]
 [0 1 0 1 0 1 0 1]
 [1 0 1 0 1 0 1 0]]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

思路：  
从0开始按顺序取十进制整数，用bin()转换为二进制，此时为字符串格式。取str[-1位]则正好是0,1,0,1交替的。换行时额外加1即可得到棋盘形式的矩阵。  
  
函数：  
bin（int）：输出字符串。

### EXERCISE 1.4

求解线性方程组
给定一个方程组，如何求出其的方程解。有多种方法，分析各种方法的优缺点（最简单的方式是消元法）。  
例如  
  
3x + 4y + 2z = 10  
5x + 3y + 4z = 14  
8x + 2y + 7z = 20  
编程写出求解的程序

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
#自己输入有点麻烦，就先拿例子当输入了
#求解:
#3x + 4y + 2z = 10
#5x + 3y + 4z = 14
#8x + 2y + 7z = 20
import numpy as ny
coe = ny.matrix([[3,4,2], [5,3,4], [8,2,7]])
nHomo = ny.matrix([[10,14,20]])
#方法1
nHomo_T = nHomo.T
re1 = coe.I * nHomo_T
x = round(re1[0,0])
y = round(re1[1,0])
z = round(re1[2,0])
print ('方法1：\n','x= ',x,'\ny= ',y,'\nz=',z,'\n')

#方法2
re2 = nHomo * coe.T.I 
x = round(re2[0,0])
y = round(re2[0,1])
z = round(re2[0,2])
print ('方法2：\n','x= ',x,'\ny= ',y,'\nz=',z,'\n')
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
方法1：
 x=  6.0 
y=  0.0 
z= -4.0 

方法2：
 x=  6.0 
y=  -0.0 
z= -4.0 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

思路：  
消元法虽然用手算很快，但由于matlab强大的矩阵运算库，我认为最简单的方法其实是利用矩阵运算。设A为系数阵，B为非齐次列向量，X为解矩阵，方程转化为$$A*X
= B$$, 则$$X = A^T * B$$或者$$X = B * A^{T^{-1}}$$。有空尝试一下消元法。  
  
函数：  
ny.matrix()：ny.arange()等函数产生的其实是多维数组（ndarray），不是matrix，matrix只是array的一个分支；只有matrix才能用于矩阵点乘、求逆等运算，而array只能对单个元素进行运算。  
round(float)：四舍五入取整。

### EXERCISE 1.5

翻转一个数组（第一个元素变成最后一个）

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
import numpy as np
a = np.arange(16).reshape(4,4)
print(a, '\n')
b = a[::-1,::-1]
print(b)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]] 

[[15 14 13 12]
 [11 10  9  8]
 [ 7  6  5  4]
 [ 3  2  1  0]]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

思路：  
就相当于从后往前排列。  
  
函数：  
a[j:i:m,k:l:n]:取下标为j到i-1以m为步长的行与下标为k到l-1以n为步长的列。

### EXERCISE 1.6

产生一个十乘十随机数组，并且找出最大和最小值

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
import numpy as np
a = np.random.randint(0,100,(10,10))
print (a)
b = np.where( a == a.max())
print ('max:',a.max(),'\nLocation:')
for i in range (len(b[0])):
    print(b[0][i], b[1][i])
    
print('\n')

c = np.where( a == a.min())
print ('min:',a.min(),'\nLocation:')
for j in range (len(c[0])):
    print(c[0][j], c[1][j])
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[[81 15 63  8 18 68 75 80 93 86]
 [62 76 84 84 26 52 30 60 13 60]
 [20 51 33 16 66 55 38  9 59 89]
 [29  3 93 94 60 91 20 44 37 76]
 [98 26 65 38 50 99 51 85 42 95]
 [32 38 92  7 62 74 19 98 81 58]
 [57 24 85 65 98 62 55 29 13 33]
 [94 47 76 40 81 71 70 27 59 26]
 [83 81  3 43 67 98 20 88 50 36]
 [78 22  1 13 69 75 23 88 11  9]]
max: 99 
Location:
4 5


min: 1 
Location:
9 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

思路：  
只找最大最小值太简单（难道不能用a.max()函数吗？），所以我又加了一个功能：找到所有最大最小值的位置。np.where函数返回一个tuple，第一项是行数组成的list，第二项是列数。遍历即可得位置信息。  
  
函数：  
np.random.randint(0,100,(10,10))：在[0,100)范围内随机取值得到10阶方阵。

2. Matplotlib
-------------

### EXERCISE 2.1

画出一个二次函数，同时画出梯形法求积分时的各个梯形 例如：

![matplot_ex1.png](attachment:matplot_ex1.png)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
import matplotlib.pyplot as plt
import numpy as np
x = np.linspace(-16,16,32)
y = x**2
fig = plt.figure()
axes = fig.add_axes([0,0,1,1])
axes.plot(x,y)

#plot第一个变量意思是x范围取定在一点，而y的范围在0到y[i]
for i in range(32):
    axes.plot([x[i],x[i]],[0,y[i]],'r')

axes.set_title(r'$y = x^2$')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.xaxis.set_ticks_position("bottom")
axes.spines["bottom"].set_position(('data',0))

plt.show()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

![](C:/Users/Administrator/Desktop/下载1.png)

思路：  
先画出函数曲线，然后循环得到每个点到x-axis的垂直线。  
  
函数：  
np.linspace(-16,16,32)：产生[-16,16]间的32个等差数列，返回行向量。  
plt.figure()：返回一个instance，允许从实例中调用并更改具体图像的参数。  
axes =
fig.add_axes([0,0,1,1])：在figure中加入两个坐标轴，前两项是空间位置，后两项是长度。  
axes.plot(x,y)：画曲线。  
axes.set_title(r'$$y = x^2$$')  
axes.set_xlabel('x')  
axes.set_ylabel('y')  
axes.xaxis.set_ticks_position("bottom")：将底部的线设为x轴。  
axes.spines["bottom"].set_position(('data',0))：将底部的线移到零点。

### EXERCISE 2.2

绘制函数 f(x)=sin2(x−2)e−x2 需要画出标题，x，y轴。x的取值范围是[0, 2]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0,2,20)
y = np.exp(-x**2)*pow(np.sin(x-2),2)

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.plot(x,y)

ax.set_title(r'$y = sin^2(x-2)e^{-x^2}$')
ax.set_xlabel('x')
ax.set_xlim([0,2])
ax.set_ylabel('y')

plt.show()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

![](C:/Users/Administrator/Desktop/下载2.png)

思路：  
就是函数的应用。要牢记。  
  
函数：  
np.exp(x)：numpy库中的指数函数，能输入矩阵。  
'￥y = sin2(x-2)e{-x\^2}￥'：latex语言文本处理。

### EXERCISE 2.2

模拟一个醉汉在二维空间上的随机漫步。 例如1维的情况是：

![random_walk.png](attachment:random_walk.png)

x轴表示步子，y轴表示游走的位置

如果对于二维，则x，y分别是游走的位置。当然也可以画成三维，其中z比表示步子。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ python
import numpy as np
import matplotlib.pyplot as plt
import math

#在[0,2pi]取100个随机方向
dirc = np.random.random(100)*2*np.pi

#竖向排列两个图，第一个为极坐标，第二个为直角坐标
fig, ax = plt.subplots(2,1)

#极坐标下展现了每步的方向和大小（定为单位步长），用每个点与原点连线组成的向量表示
ax[0] = plt.subplot(211, projection='polar')
for i in range(100):
    ax[0].plot([dirc[i],dirc[i]],[0,1],'r')

#初始化x
x = np.random.rand(100)
x[0] = 0
a = 0
#初始化y
y = np.random.rand(100)
y[0] = 0
b = 0
#每一步在x的投影为cos(dirx[i]), 在y的投影为sin(dirx[i])，然后将每一步连起来即为走过的路径
for i in range(1,100):
    a += math.cos(dirc[i-1])
    x[i] = a
    b += math.sin(dirc[i-1])
    y[i] = b
    
ax[1].plot(x,y,marker='+',markeredgecolor="red")
#处理坐标轴，使起点位于原点（坐标轴交点）
ax[1].xaxis.set_ticks_position("bottom")
ax[1].yaxis.set_ticks_position("left")
ax[1].spines["bottom"].set_position(('data',0))
ax[1].spines["left"].set_position(('data',0))
ax[1].spines["right"].set_color("none")
ax[1].spines["top"].set_color("none")

fig.savefig('exercise_2-3.pdf')

plt.show()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

![](C:/Users/Administrator/Desktop/下载3.png)

原理：  
见注释。  
  
函数：  
plt.subplots(2,1)：返回tuple，只需用到第二项，即坐标轴对象组成的list。用下标即可读取。  
fig.savefig('exercise_2-3.pdf')：自动储存图表为pdf。但坐标轴和标题经常会消失，查不到什么原因导致的。
